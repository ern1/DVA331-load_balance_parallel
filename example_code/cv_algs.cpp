#include "opencv2/opencv.hpp"
#include <stdio.h>
#include "opencv2/xfeatures2d/nonfree.hpp"
#include "/usr/local/include/opencv2/highgui/highgui.hpp"
#include "/usr/local/include/opencv2/imgcodecs/imgcodecs.hpp"
#include "opencv2/core/core.hpp"
#include <opencv2/objdetect/objdetect.hpp>
#include <time.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <iomanip>
#include <pthread.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <math.h>
#include "papi.h"
#include <sys/time.h>
#include <chrono>
#include <papi.h>
#include <pthread.h>
#include "wrapper.h"

using namespace cv;
using namespace std;
#define CORES 4
double exec_times_out[4];
long long int values_out[4];
Mat frame;

cv::Mat * roi;
int Global_Width;
int Global_Height;
pthread_barrier_t our_barrier;
#define QUEUE_NAME "/performance_counters"

int stick_this_thread_to_core(int core_id) {
	int num_cores = sysconf(_SC_NPROCESSORS_ONLN);
	if (core_id < 0 || core_id >= num_cores)
  {
    printf("Core out of index");
    return 0;
  }

  cpu_set_t cpuset;
  CPU_ZERO(&cpuset);
  CPU_SET(core_id, &cpuset);

  pthread_t current_thread = pthread_self();    
  return pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset);
}

static inline long long unsigned time_ns(struct timespec* const ts) {
  /* We use monotonic to avoid any leap-problems generated by NTP. */
  if (clock_gettime(CLOCK_MONOTONIC, ts)) {
    exit(1);
  }
  return ((long long unsigned) ts->tv_sec) * 1000000000LLU
    + (long long unsigned) ts->tv_nsec;
}



void * cv_thread(void * current_core)
{
	mqd_t mq;
	int retval;
	int cache_count;
		planet_type message;
  	int monitor_pid = syscall(SYS_gettid);
	//printf("Current thread id: %d", monitor_pid);
	int EventSet = PAPI_NULL;
	int native = perf::PERF_COUNT_HW_BUS_CYCLES | 0;
	int number = 0;
	long long int values[1];
	int frames_executed = 0;
	double exec_times[100];
	double performance_counters[100];
	MQconnect(&mq, QUEUE_NAME);
	
	if ( (retval=PAPI_register_thread())!= PAPI_OK )
      		printf("Failed to register thread");

    	if ( (retval = PAPI_create_eventset(&EventSet)) != PAPI_OK)
      		printf("Failed to create eventset");
  
      	if ( (retval = PAPI_add_event(EventSet, PAPI_L3_TCM)) != PAPI_OK)
        	printf("failed to attach L2 misses");
    	
	if ((retval = PAPI_attach(EventSet, monitor_pid)) != PAPI_OK)
      		printf("Failed to attach tid to eventset");
   
    	if ( (retval = PAPI_start(EventSet)) != PAPI_OK)
      			printf("Failed to start papi");

	int core = (int)current_core;
	char            t_str[64];
    		long long unsigned timestamp;
    		long long unsigned timestamp_after;
    		struct timespec ts;
		double exec = 0.0;
	/*cv::Rect roi_rect = cv::Rect (0,0, 800,800);
  	roi[core] = frame(roi_rect);*/
	int local_x = 0;
	int local_y;
	if (core == 0)
	{
		local_y = 0;
	}
	else
	{
		local_y = (int)Global_Height/CORES*core-1;
	}
	int local_width = Global_Width;
	int local_height = (int)Global_Height/CORES;
	//printf("Core: %d Y: %d Width: %d, Height %d\n", core, local_y, local_width, local_height);
	//fflush(stdout); DRAM BANKAR!!!??
	cv::Mat roi;
	timestamp = time_ns(&ts);
	std::vector<cv::KeyPoint> kpts; //Keypoints
	cv::Rect roi_rect = cv::Rect (local_x,local_y, local_width,local_height);
	
  	roi = frame(roi_rect);
	
	Ptr<xfeatures2d::SIFT> detector = xfeatures2d::SIFT::create(200);
	detector->detect(roi,kpts,Mat());
	drawKeypoints(roi, kpts, roi, Scalar(255, 0, 255), DrawMatchesFlags::DEFAULT);
	timestamp_after = time_ns(&ts);
	exec = (double)(timestamp_after-timestamp)*0.000001;
	//exec_times[frames_executed] = exec,
		//frames_executed++;
	if ( (retval=PAPI_read(EventSet, values)) != PAPI_OK)
        	printf("Failed to read the events");
	
	//std::cout << "Performance counters for core: "<< core <<"\t" << values[0] << std::endl;
		//printf("%llu \n", values[0]);
		//double fps1 = cv::getTickFrequency() / (cv::getTickCount() - start);
		message.pid = core;
		message.perf_counter = values[0];
		message.target_performance = 200;
		char buffer[32];
		snprintf(message.performance, sizeof(message.performance), "%g", exec);
	exec_times_out[core] = exec;
	values_out[core] = values[0];
		//std::cout << "Core: " << core << "Execution time: " << exec << " Performance counters: " << values[0] <<std::endl;
		MQwrite(&mq, &message);
	if ((retval = PAPI_stop(EventSet, values)) != PAPI_OK)
	{
		printf("Failed to stop the eventset");
	}
	//pthread_barrier_wait(&our_barrier);
		//std::cout << fps1 << " " << exec << " " << message.perf_counter << std::endl;
	/*if (core == 0)
	{
		imshow( "Frame", roi);
	}
	else if (core == 1)
	{
		imshow( "Frame2", roi);
	}
	else if (core == 2)
	{
		imshow( "Frame3", roi);
	}
	else
	{
		imshow( "Frame4", roi);
	}*/
	mq_close(mq);
}
void video(int alg)
{
	int retval;
	if((retval = PAPI_library_init(PAPI_VER_CURRENT)) != PAPI_VER_CURRENT )
		printf("Failed to initialize papi");
	if ((retval = PAPI_thread_init(&pthread_self)) != PAPI_OK)
		printf("Failed to init papi thread");

	printf("Hello");
	
	
	pthread_barrier_init(&our_barrier,NULL,3);
	
	void * status;
	int thread_ec;
		
		
	VideoCapture cap("drone.mp4"); 
        cap.set(CV_CAP_PROP_FOURCC, CV_FOURCC('H', '2', '6', '4'));
	/*pthread_t threads[24];
  	pthread_attr_t attr;
  	pthread_attr_init(&attr);
  	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
   	thread_ec = pthread_create(&threads[0], &attr, message_thread, (void*)1);*/
	
	// Check if camera opened successfully
	if(!cap.isOpened()){
	cout << "Error opening video stream or file" << endl;
		return;
	}
	
	planet_type message;
	pthread_t threads[4];
  	pthread_attr_t attr;
  	pthread_attr_init(&attr);
  	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
   	
	//message=(planet_type *)malloc(sizeof(planet_type));
	while(1)
	{
		char            t_str[64];
    		long long unsigned timestamp;
    		long long unsigned timestamp_after;
    		struct timespec ts;
		double exec = 0.0;
		
		double fps = cap.get(CV_CAP_PROP_FPS);
		long start = cv::getTickCount();
    		
		
		cap >> frame;
		Mat dst;
		Global_Width = frame.size().width;
		Global_Height = frame.size().height;
		int size = frame.elemSize();
		int cols = frame.cols;
		int rows = frame.rows;
		int total_size = size*cols*rows;
		
		
		//printf("Elem size %d", total_size);
		if (alg == 1) //FAST corner
		{
			
			for (int i = 0; i < CORES; i++)
			{
				thread_ec = pthread_create(&threads[i], NULL, cv_thread, (void*)i);
				
			}
			for (int i = 0; i < 4; i++)
			{
				std::cout << exec_times_out[i] << "\t" << values_out[i] <<"\t";
			}
			std::cout << std::endl;
			for (int i = 0; i < CORES; i++)
			{
				thread_ec = pthread_join(threads[i], &status);
			}	
			//printf("Execution time: %f", exec);		
		}
		double fps1 = cv::getTickFrequency() / (cv::getTickCount() - start);
    		// Capture frame-by-frame
		// If the frame is empty, break immediately
		if (frame.empty())
		{
			printf("Empty frame");
      			break;
		} 
		// Display the resulting frame
    		//imshow( "Frame", roi);
 		
    		char c=(char)waitKey(25);
    		if(c==27)
      			break;
		
		//std::cout << "fps: " << fps1 << std::endl;
		//std::cout<<"size: " << sizeof(message) <<" pid: " << monitor_pid << " FPS: " << fps1 << " peformane counter: " << message.perf_counter<< std::endl;
  	}
  	cap.release();
  	// Closes all the frames
  	destroyAllWindows();     
	//thread_ec = pthread_join(threads[0], &status);
  	return;
}

int main( int argc, char** argv )
{
	//stick_this_thread_to_core(3);
	video(1);
	//feature(argv[1], atoi(argv[2]));
}
